..java:1:    PackageCase:    Package name contains upper case characters
..java:3:    UnnecessaryImport:      Unused import 'java.io.Console'
..java:6:    AtLeastOneConstructor:  Each class should declare at least one constructor
..java:8:    CommentDefaultAccessModifier:   To avoid mistakes add a comment at the beginning of the maxCapacity field if you want a default access modifier
..java:8:    DefaultPackage: Use explicit scoping instead of the default package private level
..java:9:    LooseCoupling:  Avoid using implementation types like 'ArrayList'; use the interface instead
..java:9:    CommentDefaultAccessModifier:   To avoid mistakes add a comment at the beginning of the itemWeights field if you want a default access modifier
..java:9:    DefaultPackage: Use explicit scoping instead of the default package private level
..java:10:   LooseCoupling:  Avoid using implementation types like 'ArrayList'; use the interface instead
..java:10:   CommentDefaultAccessModifier:   To avoid mistakes add a comment at the beginning of the itemProfits field if you want a default access modifier
..java:10:   DefaultPackage: Use explicit scoping instead of the default package private level
..java:11:   CommentDefaultAccessModifier:   To avoid mistakes add a comment at the beginning of the maxChosenProfit field if you want a default access modifier
..java:11:   DefaultPackage: Use explicit scoping instead of the default package private level
..java:12:   CommentDefaultAccessModifier:   To avoid mistakes add a comment at the beginning of the availableItems field if you want a default access modifier
..java:12:   DefaultPackage: Use explicit scoping instead of the default package private level
..java:14:   MethodArgumentCouldBeFinal:     Parameter 'NumOfItems' is not assigned and could be declared final
..java:14:   MethodArgumentCouldBeFinal:     Parameter 'Weight' is not assigned and could be declared final
..java:14:   FormalParameterNamingConventions:       The method parameter name 'NumOfItems' doesn't match '[a-z][a-zA-Z0-9]*'
..java:14:   FormalParameterNamingConventions:       The method parameter name 'Weight' doesn't match '[a-z][a-zA-Z0-9]*'   
..java:17:   OnlyOneReturn:  A method should have only one exit point, and that should be the last statement in the method  
..java:17:   ControlStatementBraces: This statement should have braces
..java:19:   OnlyOneReturn:  A method should have only one exit point, and that should be the last statement in the method  
..java:19:   ControlStatementBraces: This statement should have braces
..java:21:   OnlyOneReturn:  A method should have only one exit point, and that should be the last statement in the method  
..java:38:   LocalVariableCouldBeFinal:      Local variable 'email' could be declared final
..java:39:   SystemPrintln:  System.out.println is used
..java:42:   ShortVariable:  Avoid variables with short names like a
..java:42:   ShortVariable:  Avoid variables with short names like b
..java:42:   MethodArgumentCouldBeFinal:     Parameter 'a' is not assigned and could be declared final
..java:42:   MethodArgumentCouldBeFinal:     Parameter 'b' is not assigned and could be declared final
..java:43:   UselessParentheses:     Useless parentheses.
..java:46:   MethodArgumentCouldBeFinal:     Parameter 'args' is not assigned and could be declared final
..java:48:   ShortVariable:  Avoid variables with short names like SW
..java:48:   LocalVariableCouldBeFinal:      Local variable 'SW' could be declared final
..java:48:   LocalVariableNamingConventions: The local variable name 'SW' doesn't match '[a-z][a-zA-Z0-9]*'
..java:51:   LawOfDemeter:   Potential violation of Law of Demeter (static property access)
..java:52:   LawOfDemeter:   Potential violation of Law of Demeter (static property access)
..java:53:   LawOfDemeter:   Potential violation of Law of Demeter (static property access)
..java:54:   LawOfDemeter:   Potential violation of Law of Demeter (static property access)
..java:55:   LawOfDemeter:   Potential violation of Law of Demeter (static property access)
..java:56:   LawOfDemeter:   Potential violation of Law of Demeter (static property access)
..java:58:   LawOfDemeter:   Potential violation of Law of Demeter (static property access)
..java:59:   LawOfDemeter:   Potential violation of Law of Demeter (static property access)
..java:60:   LawOfDemeter:   Potential violation of Law of Demeter (static property access)
..java:61:   LawOfDemeter:   Potential violation of Law of Demeter (static property access)
..java:62:   LawOfDemeter:   Potential violation of Law of Demeter (static property access)
..java:63:   LawOfDemeter:   Potential violation of Law of Demeter (static property access)
..java:73:   SystemPrintln:  System.out.println is used
..java:85:   UseUnderscoresInNumericLiterals:        Number 10000 should separate every third digit with an underscore      
..java:85:   UseUnderscoresInNumericLiterals:        Number 49877 should separate every third digit with an underscore      
..java:86:   SystemPrintln:  System.out.println is used


CollapsibleIfStatements:0
LongVariable:0
ForLoopVariableCount:0
UnusedLocalVariable:0
AddEmptyString:0
CyclomaticComplexity:0
AvoidDeeplyNestedIfStmts:0
UnusedAssignment:0
MethodArgumentCouldBeFinal:5
AvoidInstantiatingObjectsInLoops:0
PrematureDeclaration:0
ShortVariable:3
ControlStatementBraces:2
UnusedFormalParameter:0
LocalVariableCouldBeFinal:2


Great implementation for small inputs , but as the number of inputs increase , your overlapping subproblems increase in recursion and you end up using more computational power to compute the same problem multiple times
so the solution to this is to store the results of the subproblems , when faced with the problem again , you retreive the pre-computed result from before.
Read more on dynamic programming and check the attatched file.
